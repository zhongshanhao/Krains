(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{549:function(t,a,s){"use strict";s.r(a);var v=s(4),_=Object(v.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"java特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java特性"}},[t._v("#")]),t._v(" Java特性")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("封装")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("是什么？")]),t._v(" "),s("p",[t._v("在Java中，一切皆对象。封装，就是把客观事物封装成抽象的类，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。")])]),t._v(" "),s("li",[s("p",[t._v("有什么好处？")]),t._v(" "),s("p",[t._v("我们将复杂的功能封装到一个类中，对外开放一个接口，我们在使用的时候不用管里面复杂的逻辑，直接调用即可完成功能。")])])])]),t._v(" "),s("li",[s("p",[t._v("继承")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("是什么？\n继承是一个对象获取另一个对象中属性的方法。")])]),t._v(" "),s("li",[s("p",[t._v("有什么好处？\n继承可以大幅减少冗余的代码，并且可基于父类的基础上扩展代码，增加功能，提高开发效率。")])])])]),t._v(" "),s("li",[s("p",[t._v("多态")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("是什么？\n用超类可引用其所有的子类，若不同的子类覆写了父类的一个方法，则用超类引用不同子类时调用该方法会执行实际子类的方法，这种由一个对象引用时调用方法反映的是实际子类的方法的特性叫做多态。如用List接口引用了一个参数，调用get方法取决与其实际类型是ArrayList还是LinkedList。")])]),t._v(" "),s("li",[s("p",[t._v("有什么好处？")]),t._v(" "),s("p",[t._v("提高了代码的扩展性。")])])])])]),t._v(" "),s("h2",{attrs:{id:"修饰符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#修饰符"}},[t._v("#")]),t._v(" 修饰符")]),t._v(" "),s("ol",[s("li",[s("code",[t._v("final")])])]),t._v(" "),s("ul",[s("li",[s("p",[t._v("作用在类上\n表示该类不可以被继承")])]),t._v(" "),s("li",[s("p",[t._v("作用在方法上\n表示该方法不可以被覆写")])]),t._v(" "),s("li",[s("p",[t._v("作用在字段上\n表示该字段不能被修改，对于基本类型，其值不能被修改，对于引用类型，表示不能在引用其他对象，但是可以修改引用对象本身。")])])]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[s("p",[s("code",[t._v("static")])]),t._v(" "),s("ul",[s("li",[s("p",[t._v("作用在成员变量上\n被称为静态字段，静态字段只有一个共享的空间，在类的所有实例中共享静态字段。")])]),t._v(" "),s("li",[s("p",[t._v("作用在方法上\n被称为静态方法，静态方法能够在不创建实例的情况下通过类名直接调用，如"),s("code",[t._v("Math.max()")]),t._v("；\n静态方法不能调用非静态的方法和成员变量。")])])])]),t._v(" "),s("li",[s("p",[s("code",[t._v("private")])]),t._v(" "),s("p",[t._v("私有访问修饰符，被声明为private的方法、变量和构造方法只能被所属类（其实例或子类也不能访问）访问，被private修饰的方法和变量的作用域只在其类内部（不能通过实例向外抛出），当然在该类的内部类也可以访问，注意类和接口不能声明为private。")])]),t._v(" "),s("li",[s("p",[s("code",[t._v("protected")])]),t._v(" "),s("p",[t._v("如果想要类中的变量或方法不被其他类访问但是可以被其子类访问，可以加protected。")])]),t._v(" "),s("li",[s("p",[s("code",[t._v("public")])]),t._v(" "),s("p",[t._v("与private相反，被声明为public的方法、变量、类和接口可以被任何其他类访问。")])])]),t._v(" "),s("h2",{attrs:{id:"抽象类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#抽象类"}},[t._v("#")]),t._v(" 抽象类")]),t._v(" "),s("p",[t._v("如果把一个方法定义为"),s("code",[t._v("abstract")]),t._v("，表示这是一个抽象方法，本身没有实现任何方法语句，因为这个抽象方法本身是无法执行的，所以其所在的类无法被实例化，必须要在类上也声明为"),s("code",[t._v("abstract")]),t._v("。")]),t._v(" "),s("p",[t._v("无法实例化的抽象类有什么用？")]),t._v(" "),s("p",[t._v("抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译器就会报错，因此，抽象方法实际上相当于定义了“规范”。")]),t._v(" "),s("p",[t._v("面向抽象编程")]),t._v(" "),s("p",[t._v("当我们定义了抽象类"),s("code",[t._v("Person")]),t._v("，其中有一个抽象的"),s("code",[t._v("run()")]),t._v("方法，当我们实现具体的"),s("code",[t._v("Student")]),t._v("、"),s("code",[t._v("Teacher")]),t._v("子类的时候，我们可以通过抽象类"),s("code",[t._v("Person")]),t._v("类型区引用具体子类的实例")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("abstract")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Person")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("abstract")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("run")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Person")]),t._v(" s "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Student")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Person")]),t._v(" t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Teacher")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br")])]),s("p",[t._v("这种引用抽象类的好处在于，我们对其进行方法调用，并不关心Person类型变量的具体子类型：")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 不关心Person变量的具体子类型，在运行时能够根据它实际的子类型调用相应的方法")]),t._v("\ns"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("run")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("run")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[t._v("同样的代码，如果引用的是一个新的子类，我们仍然不关心具体类型：")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 同样不关心新的子类是如何实现run()方法的：")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Person")]),t._v(" e "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Employee")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\ne"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("run")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[t._v("这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。")]),t._v(" "),s("p",[t._v("面向抽象编程的本质就是：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("上层代码只定义规范（例如：abstract class Person）；")])]),t._v(" "),s("li",[s("p",[t._v("不需要子类就可以实现业务逻辑（正常编译）；")])]),t._v(" "),s("li",[s("p",[t._v("具体的业务逻辑由不同的子类实现，调用者并不关心。")])])]),t._v(" "),s("h2",{attrs:{id:"接口"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#接口"}},[t._v("#")]),t._v(" 接口")]),t._v(" "),s("p",[s("code",[t._v("interface")]),t._v("是比抽象类还要抽象的纯抽象接口，接口定义的所有方法默认都是"),s("code",[t._v("public abstract")]),t._v("的，所以在定义接口时可以省略，接口中的变量会被隐式指定为"),s("code",[t._v("public static final")]),t._v("。")]),t._v(" "),s("p",[t._v("从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之\n前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。")]),t._v(" "),s("p",[t._v("抽象类和接口的区别")]),t._v(" "),s("p",[t._v("语法层面")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("继承：一个类只能单继承一个抽象类，但可以实现多个接口")])]),t._v(" "),s("li",[s("p",[t._v("字段：抽象类可以定义各种类型的成员变量，而接口的成员变量只能是"),s("code",[t._v("public static final")]),t._v("类型的（常量）")])]),t._v(" "),s("li",[s("p",[t._v("方法：抽象类可以定义非抽象方法，接口可以定义default和static（JDK1.8后）方法（为了防止在接口中新增方法时影响其他已经实现了该接口的实现类报错[抽象方法必须被子类重写]而打的补丁）")])])]),t._v(" "),s("p",[t._v("设计层面")]),t._v(" "),s("ul",[s("li",[t._v("接口侧重功能设计，能够将具体实现与调用者隔离，降低模块间的耦合")]),t._v(" "),s("li",[t._v("抽象类侧重提升类的复用性，在原有的基础上预留扩展点供开发者灵活实现")])]),t._v(" "),s("h2",{attrs:{id:"基本数据类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基本数据类型"}},[t._v("#")]),t._v(" 基本数据类型")]),t._v(" "),s("p",[t._v("Java中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？\nJava中有8种基本数据类型，分别为：")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("基本类型")]),t._v(" "),s("th",[t._v("位数")]),t._v(" "),s("th",[t._v("字节")]),t._v(" "),s("th",[t._v("默认值")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("int")]),t._v(" "),s("td",[t._v("32")]),t._v(" "),s("td",[t._v("4")]),t._v(" "),s("td",[t._v("0")])]),t._v(" "),s("tr",[s("td",[t._v("short")]),t._v(" "),s("td",[t._v("16")]),t._v(" "),s("td",[t._v("2")]),t._v(" "),s("td",[t._v("0")])]),t._v(" "),s("tr",[s("td",[t._v("long")]),t._v(" "),s("td",[t._v("64")]),t._v(" "),s("td",[t._v("8")]),t._v(" "),s("td",[t._v("0L")])]),t._v(" "),s("tr",[s("td",[t._v("byte")]),t._v(" "),s("td",[t._v("8")]),t._v(" "),s("td",[t._v("1")]),t._v(" "),s("td",[t._v("0")])]),t._v(" "),s("tr",[s("td",[t._v("char")]),t._v(" "),s("td",[t._v("16")]),t._v(" "),s("td",[t._v("2")]),t._v(" "),s("td",[t._v("'u0000'")])]),t._v(" "),s("tr",[s("td",[t._v("float")]),t._v(" "),s("td",[t._v("32")]),t._v(" "),s("td",[t._v("4")]),t._v(" "),s("td",[t._v("0f")])]),t._v(" "),s("tr",[s("td",[t._v("double")]),t._v(" "),s("td",[t._v("64")]),t._v(" "),s("td",[t._v("8")]),t._v(" "),s("td",[t._v("0d")])]),t._v(" "),s("tr",[s("td",[t._v("boolean")]),t._v(" "),s("td",[t._v("1")]),t._v(" "),s("td"),t._v(" "),s("td",[t._v("false")])])])]),t._v(" "),s("p",[t._v("对于boolean，官方文档未明确定义，它依赖于 JVM 厂商的具体实现，一般当做int变量来处理，占4个字节。逻辑上理解是占用 1位，但是实际中会考虑计算机高效存储因素。")]),t._v(" "),s("p",[t._v("Java中负数是如何存储的？")]),t._v(" "),s("p",[t._v("以-1为例，取其绝对值的原码，在取该原码的补码。")]),t._v(" "),s("p",[t._v("为何如此？")]),t._v(" "),s("p",[t._v("计算机中只有加法，所以计算减法的时候需要将减法传为加法。计算 a - b 就相当于 a + (-b)，对应的把他们的二进制相加就能够得到结果，正数用原码表示，而负数用其相反数原码的补码表示。")])])}),[],!1,null,null,null);a.default=_.exports}}]);